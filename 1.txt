from flask import Flask, request, jsonify
from flask_cors import CORS 
import os, sys, time, json
import requests
import base64

# üéØ FIX: Import Logic Serial Control (‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ)
sys.path.append(os.path.join(os.path.dirname(__file__), '.'))
import serial_control as sc 
# ‚ö†Ô∏è ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à‡∏ß‡πà‡∏≤ merge ‡πÅ‡∏•‡∏∞ detect ‡∏ñ‡∏π‡∏Å Import ‡πÉ‡∏ô local_listener.py ‡πÅ‡∏•‡πâ‡∏ß

app = Flask(__name__)
CORS(app) 

# üéØ -----------------------------------------------------------------
# GLOBAL STATE: ‡πÉ‡∏ä‡πâ‡πÄ‡∏Å‡πá‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå AI ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏î‡πâ
# -----------------------------------------------------------------
GLOBAL_AI_RESULT = {
    "object_order": [], 
    "object_centers": {}, # üéØ FIX: ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô Dictionary {ID: [X, Y]} ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏á‡πà‡∏≤‡∏¢
    "last_run_time": 0
}
# -----------------------------------------------------------------


def image_to_base64(filepath):
    """Transforms image file to Base64 string for embedding in JSON."""
    # ... (‡πÇ‡∏Ñ‡πâ‡∏î Base64 Encoding ‡∏Ñ‡∏á‡πÄ‡∏î‡∏¥‡∏°) ...
    try:
        with open(filepath, "rb") as image_file:
            encoded_string = base64.b64encode(image_file.read()).decode('utf-8')
        return f"data:image/jpeg;base64,{encoded_string}"
    except Exception as e:
        print(f"Error encoding image: {e}")
        return ""

def read_latest_ai_data(filepath="Model/output.json"):
    """Reads latest AI output data from the local JSON file."""
    try:
        # üéØ FIX: ‡πÉ‡∏ä‡πâ os.path.join ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ Path ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
        # ‡πÇ‡∏Ñ‡πâ‡∏î‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏≠‡∏≠‡∏Å‡πÅ‡∏ö‡∏ö‡∏°‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡πÉ‡∏ô local_listener.py ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
        full_path = os.path.join(os.path.dirname(__file__), '..', filepath) 
        with open(full_path, 'r') as f:
            data = json.load(f)
        return data
    except Exception as e:
        print(f"‚ùå ERROR reading AI JSON file: {e}")
        return None


def process_and_detect_ai():
    global GLOBAL_AI_RESULT
    
    # 1. üü¢ Capture & Stitch: (‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ß‡πà‡∏≤ Logic ‡∏ô‡∏µ‡πâ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á)
    # ‚ö†Ô∏è ‡πÇ‡∏Ñ‡πâ‡∏î‡∏à‡∏£‡∏¥‡∏á‡∏Ñ‡∏ß‡∏£‡πÉ‡∏ä‡πâ merge.capture_img ‡πÅ‡∏•‡∏∞ merge.stitch_img
    # ‚ö†Ô∏è ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏à‡∏≤‡∏Å JSON File ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ó‡∏î‡∏™‡∏≠‡∏ö
    
    # ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå output.json ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î (‡∏ó‡∏µ‡πà detect.py ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡∏∂‡πâ‡∏ô)
    ai_results_data = read_latest_ai_data("Model/output.json")
    
    if not ai_results_data or ai_results_data.get('obj_count', 0) == 0:
        raise Exception("AI detection reported no objects.")

    # üéØ 3. üü¢ ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï Global State ‡∏î‡πâ‡∏ß‡∏¢‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå Center Coordinates
    object_centers_dict = {}
    object_order_list = []
    
    for obj in ai_results_data['objects']:
        obj_id = obj['object_id'] # ID ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡πÅ‡∏•‡πâ‡∏ß 1, 2, 3...
        
        # üéØ ‡πÄ‡∏Å‡πá‡∏ö‡∏û‡∏¥‡∏Å‡∏±‡∏î Center X ‡πÅ‡∏•‡∏∞ Center Y
        # NOTE: ‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡πÉ‡∏ä‡πâ object_id ‡πÄ‡∏õ‡πá‡∏ô Key ‡πÉ‡∏ô Dictionary
        object_centers_dict[obj_id] = {
            'x': obj.get('object_center', [0, 0])[0], 
            'y': obj.get('object_center', [0, 0])[1]
        }
        object_order_list.append(obj_id) # ‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏£‡∏î‡∏ô‡πâ‡∏≥

    GLOBAL_AI_RESULT.update({
        "object_order": object_order_list,
        "object_centers": object_centers_dict,
        "last_run_time": time.time()
    })

    # 4. üü¢ Base64 Encode:
    # ‚ö†Ô∏è ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ Path ‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
    stitched_path = "Model/img_detection/detected.jpg" 
    image_base64_data = image_to_base64(stitched_path)
    
    # 5. üü¢ Return Final Data
    return {
        "image_url": image_base64_data,
        "object_count": ai_results_data['obj_count'],
        "object_order": object_order_list
    }

# ----------------- üéØ Endpoint Water Specific (‡∏£‡∏î‡∏ô‡πâ‡∏≥‡∏ï‡∏≤‡∏°‡∏û‡∏¥‡∏Å‡∏±‡∏î) -----------------

@app.route('/api/water', methods=['POST'])
def local_water_specific():
    global GLOBAL_AI_RESULT
    content = request.get_json()
    object_id = content.get('object_id') # ID ‡∏ó‡∏µ‡πà Frontend ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏£‡∏î‡∏ô‡πâ‡∏≥ (1, 2, 3...)
    
    if object_id is None:
        return jsonify({"status": "error", "message": "Missing object_id"}), 400

    # 1. üéØ ‡∏î‡∏∂‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏à‡∏≤‡∏Å Global State
    center_coords = GLOBAL_AI_RESULT["object_centers"].get(object_id)
    
    if not center_coords:
        return jsonify({"status": "error", "message": f"Object ID {object_id} not found in recent scan data."}), 404
        
    x_pos = center_coords['x']
    y_pos = center_coords['y']

    # 2. üö® ‡πÇ‡∏Ñ‡πâ‡∏î‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏° Serial Port: ‡∏™‡πà‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î X ‡πÅ‡∏•‡∏∞ Y
    # ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ó‡∏µ‡πà ESP32 ‡∏Ñ‡∏≤‡∏î‡∏´‡∏ß‡∏±‡∏á: "MOVE_TO_WATER:355,676"
    command = f"WATER:{x_pos},{y_pos}"
    
    response = sc.send_serial_command(command)
    
    print(f"Local Device: Serial Command SENT: {command}. Response: {response}")
    
    if "ACK" in response.upper() or "COMPLETE" in response.upper(): 
        return jsonify({"status": "success", "message": f"Moved to ({x_pos}, {y_pos}) and watered."})
    else:
        return jsonify({"status": "error", "message": f"Serial command failed: {response}"}), 500

# ----------------- Endpoint Water All (‡∏£‡∏±‡∏ô‡∏ï‡∏≤‡∏°‡∏•‡∏≥‡∏î‡∏±‡∏ö) -----------------

@app.route('/api/water_all', methods=['POST'])
def api_water_all():
    """
    ‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏à‡∏≤‡∏Å Frontend ‡πÉ‡∏´‡πâ‡∏£‡∏î‡∏ô‡πâ‡∏≥‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ï‡∏≤‡∏°‡∏•‡∏≥‡∏î‡∏±‡∏ö Zig-Zag ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡πá‡∏ö‡πÑ‡∏ß‡πâ‡πÉ‡∏ô Global State
    """
    global GLOBAL_AI_RESULT
    
    object_order = GLOBAL_AI_RESULT["object_order"]
    
    if not object_order:
        return jsonify({"status": "error", "message": "No detection data found. Run AI scan first."}), 400

    print(f"Local Device: Starting WATER_ALL sequence for {len(object_order)} objects.")
    
    try:
        # üí° ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏£‡∏î‡∏ô‡πâ‡∏≥‡∏ó‡∏µ‡∏•‡∏∞‡∏à‡∏∏‡∏î‡∏ï‡∏≤‡∏°‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏ó‡∏µ‡πà AI ‡∏à‡∏±‡∏î‡πÄ‡∏£‡∏µ‡∏¢‡∏á
        for object_id in object_order:
            # üéØ ‡∏î‡∏∂‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö object_id ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            center_coords = GLOBAL_AI_RESULT["object_centers"].get(object_id)
            if not center_coords: continue 

            x_pos = center_coords['x']
            y_pos = center_coords['y']
            
            # üö® ‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á ESP32
            response = sc.send_serial_command(f"WATER:{x_pos},{y_pos}") 
            
            if "ACK" not in response.upper() and "COMPLETE" not in response.upper():
                # ‡∏ñ‡πâ‡∏≤‡∏à‡∏∏‡∏î‡πÉ‡∏î‡∏à‡∏∏‡∏î‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß ‡πÉ‡∏´‡πâ‡∏¢‡∏∏‡∏ï‡∏¥
                return jsonify({"status": "error", "message": f"Watering failed at object {object_id}: {response}"}), 500
            
            # üí° ‡∏´‡∏ô‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏£‡∏î‡∏ô‡πâ‡∏≥‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏à‡∏∏‡∏î (‡πÉ‡∏´‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡∏õ‡∏±‡πä‡∏°‡∏ó‡∏≥‡∏á‡∏≤‡∏ô)
            time.sleep(1.5) 
            
        return jsonify({"status": "success", "message": f"Successfully watered {len(object_order)} objects."})

    except Exception as e:
        return jsonify({"status": "error", "message": f"Fatal error during water_all sequence: {e}"}), 500

# ... (‡∏™‡πà‡∏ß‡∏ô Health Check ‡πÅ‡∏•‡∏∞ if __name__ ‡∏Ñ‡∏á‡πÄ‡∏î‡∏¥‡∏°) ...